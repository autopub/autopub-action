name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # Run all linters using pre-commit action
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - uses: pre-commit/action@v3.0.1

  # Verify documentation matches action definition
  docs-sync:
    name: Documentation Sync
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install yq
        uses: mikefarah/yq@v4

      - name: Check inputs are documented
        run: |
          echo "Checking that all action inputs are documented in README.md..."

          # Get all input names from action.yml
          INPUTS=$(yq e '.inputs | keys | .[]' action.yml)

          MISSING=""
          for input in $INPUTS; do
            # Check if input is mentioned in README (in the inputs table)
            if ! grep -q "| \`$input\`" README.md; then
              MISSING="$MISSING $input"
            fi
          done

          if [[ -n "$MISSING" ]]; then
            echo "::error::The following inputs are not documented in README.md:$MISSING"
            exit 1
          fi
          echo "All inputs are documented"

      - name: Check outputs are documented
        run: |
          echo "Checking that all action outputs are documented in README.md..."

          # Get all output names from action.yml
          OUTPUTS=$(yq e '.outputs | keys | .[]' action.yml)

          MISSING=""
          for output in $OUTPUTS; do
            # Check if output is mentioned in README (in the outputs table)
            if ! grep -q "| \`$output\`" README.md; then
              MISSING="$MISSING $output"
            fi
          done

          if [[ -n "$MISSING" ]]; then
            echo "::error::The following outputs are not documented in README.md:$MISSING"
            exit 1
          fi
          echo "All outputs are documented"

  # Integration tests - test the action in real scenarios
  tests:
    name: Test (${{ matrix.test }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - test: check-with-release
            has-release: "true"
            release-type: patch
          - test: check-no-release
            has-release: "false"
          - test: check-fail-on-missing
            should-fail: true
          - test: invalid-command
            should-fail: true
          - test: full-flow
            has-release: "true"
            release-type: minor
    steps:
      - uses: actions/checkout@v4

      - name: Create mock project
        run: |
          cat > pyproject.toml << 'EOF'
          [project]
          name = "test-package"
          version = "0.1.0"

          [build-system]
          requires = ["hatchling"]
          build-backend = "hatchling.build"

          [tool.autopub]
          plugins = ["uv"]
          EOF

          # Create minimal package structure for build test
          mkdir -p src/test_package
          echo '__version__ = "0.1.0"' > src/test_package/__init__.py

      - name: Create RELEASE.md (for release tests)
        if: matrix.test == 'check-with-release' || matrix.test == 'full-flow'
        run: |
          cat > RELEASE.md << 'EOF'
          ---
          release type: ${{ matrix.release-type }}
          ---

          This is a test release for CI validation.
          EOF

      - name: Run check command
        if: matrix.test == 'check-with-release' || matrix.test == 'check-no-release' || matrix.test == 'full-flow'
        id: check
        uses: ./
        with:
          command: check
          autopub-version: pre-release
          upload-artifact: "false"

      - name: Run prepare command (full-flow)
        if: matrix.test == 'full-flow'
        uses: ./
        with:
          command: prepare
          autopub-version: pre-release
          download-artifact: "false"

      - name: Run build command (full-flow)
        if: matrix.test == 'full-flow'
        uses: ./
        with:
          command: build
          autopub-version: pre-release
          download-artifact: "false"

      - name: Verify build artifacts (full-flow)
        if: matrix.test == 'full-flow'
        run: |
          echo "Checking that dist/ was created..."
          if [[ ! -d "dist" ]]; then
            echo "::error::dist/ directory was not created"
            exit 1
          fi
          ls -la dist/
          echo "Build artifacts created successfully"

      - name: Run check with fail-on-missing
        if: matrix.test == 'check-fail-on-missing'
        id: check-fail
        uses: ./
        with:
          command: check
          fail-on-missing: "true"
          autopub-version: pre-release
          upload-artifact: "false"
        continue-on-error: true

      - name: Run with invalid command
        if: matrix.test == 'invalid-command'
        id: invalid
        uses: ./
        with:
          command: invalid-command
        continue-on-error: true

      - name: Verify outputs (check-with-release)
        if: matrix.test == 'check-with-release' || matrix.test == 'full-flow'
        run: |
          if [[ "${{ steps.check.outputs.has-release }}" != "${{ matrix.has-release }}" ]]; then
            echo "::error::Expected has-release to be '${{ matrix.has-release }}'"
            exit 1
          fi
          if [[ "${{ steps.check.outputs.release-type }}" != "${{ matrix.release-type }}" ]]; then
            echo "::error::Expected release-type to be '${{ matrix.release-type }}'"
            exit 1
          fi

      - name: Verify outputs (check-no-release)
        if: matrix.test == 'check-no-release'
        run: |
          if [[ "${{ steps.check.outputs.has-release }}" != "false" ]]; then
            echo "::error::Expected has-release to be 'false'"
            exit 1
          fi

      - name: Verify failure (fail-on-missing)
        if: matrix.test == 'check-fail-on-missing'
        run: |
          if [[ "${{ steps.check-fail.outcome }}" != "failure" ]]; then
            echo "::error::Expected action to fail with fail-on-missing=true"
            exit 1
          fi

      - name: Verify failure (invalid-command)
        if: matrix.test == 'invalid-command'
        run: |
          if [[ "${{ steps.invalid.outcome }}" != "failure" ]]; then
            echo "::error::Expected action to fail with invalid command"
            exit 1
          fi

  # Test full publish flow with local PyPI server
  test-publish:
    name: Test (publish)
    runs-on: ubuntu-latest
    services:
      pypiserver:
        image: pypiserver/pypiserver:latest
        ports:
          - 8080:8080
        options: >-
          --health-cmd "wget --spider http://localhost:8080 || exit 1"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4

      - name: Create mock project
        run: |
          # Use unique package name to avoid conflicts
          PACKAGE_NAME="test-package-${{ github.run_id }}"

          cat > pyproject.toml << EOF
          [project]
          name = "$PACKAGE_NAME"
          version = "0.1.0"

          [build-system]
          requires = ["hatchling"]
          build-backend = "hatchling.build"

          [tool.autopub]
          plugins = ["uv"]
          EOF

          mkdir -p "src/${PACKAGE_NAME//-/_}"
          echo '__version__ = "0.1.0"' > "src/${PACKAGE_NAME//-/_}/__init__.py"

          cat > RELEASE.md << 'EOF'
          ---
          release type: patch
          ---

          Test release for publish flow validation.
          EOF

      - name: Initialize git repo (required for publish)
        run: |
          git config user.name "Test"
          git config user.email "test@test.com"
          git init
          git add .
          git commit -m "Initial commit"

      - name: Run check
        uses: ./
        with:
          command: check
          autopub-version: pre-release
          upload-artifact: "false"

      - name: Run prepare
        uses: ./
        with:
          command: prepare
          autopub-version: pre-release
          download-artifact: "false"

      - name: Run build
        uses: ./
        with:
          command: build
          autopub-version: pre-release
          download-artifact: "false"

      - name: Run publish (to local pypiserver)
        uses: ./
        with:
          command: publish
          autopub-version: pre-release
          download-artifact: "false"
          publish-repository: "http://localhost:8080"
          pypi-token: "dummy-token"

      - name: Verify package was published
        run: |
          PACKAGE_NAME="test-package-${{ github.run_id }}"
          echo "Checking if package was published to local PyPI server..."

          # List packages on the server
          curl -s http://localhost:8080/simple/ | grep -q "${PACKAGE_NAME//-/_}" || {
            echo "::error::Package was not found on local PyPI server"
            curl -s http://localhost:8080/simple/
            exit 1
          }
          echo "Package published successfully!"

  # All tests must pass
  all-tests:
    name: All Tests Passed
    needs: [lint, docs-sync, tests, test-publish]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Check all jobs passed
        run: |
          if [[ "${{ needs.lint.result }}" != "success" ]]; then
            echo "::error::Lint job failed"
            exit 1
          fi
          if [[ "${{ needs.docs-sync.result }}" != "success" ]]; then
            echo "::error::Docs sync job failed"
            exit 1
          fi
          if [[ "${{ needs.tests.result }}" != "success" ]]; then
            echo "::error::Tests failed"
            exit 1
          fi
          if [[ "${{ needs.test-publish.result }}" != "success" ]]; then
            echo "::error::Publish test failed"
            exit 1
          fi
          echo "All tests passed!"
